---
title: InnoDB锁的实现
date: 2020-08-26 23:41:12
categories: 
           - mysql
tags:
           - InnoDB
           - 锁
---


## 一、锁的定义

> 开发数据库的难点：一方面要最大程度地利用数据库的并发访问，另一方面还要确保每个用户能以一致的方式读取和修改数据。
>
> 数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。

- InnoDB存储引擎的锁是行级锁。MyISAM引擎的锁是表锁设计。



## 二、lock与latch

| 内容     | lock                                            | latch                                                        |
| -------- | ----------------------------------------------- | ------------------------------------------------------------ |
| 对象     | 事务                                            | 线程                                                         |
| 保护     | 数据库内容                                      | 内存数据结构                                                 |
| 持续时间 | 整个事务过程                                    | 临界资源                                                     |
| 模式     | 行锁、表锁、意向锁                              | 读写锁、互斥量                                               |
| 死锁     | 通过waits-for graph、time out等级制进行死锁检测 | 无死锁检测与处理机制。仅通过应用程序的顺序保证无死锁的情况发生 |
| 存在于   | Lock Manager的哈希表中                          | 每个数据结构的对象中                                         |



## 三、InnoDB存储引擎中的锁

### 1.锁的类型

#### S锁与X锁

InnoDB存储引擎实现了两种标准的行级锁：

- 共享锁（S Lock），允许事务读一行数据
- 排他锁（X Lock），允许事务删除或更新一行数据

|      | X      | S      |
| ---- | ------ | ------ |
| X    | 不兼容 | 不兼容 |
| S    | 不兼容 | 兼容   |

#### 意向锁

为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持意向锁，其设计为表级别的意向锁。

- 意向共享锁（IS Lock），事务想要获得一张表中的某几行的共享锁
- 意向排他锁（IX Lock），事务想要获得一张表中的某几行的排他锁

简单来说，事务想要对行级别的数据上锁之前，需要对表级别的上意向锁，以下为意向锁和普通锁之间的兼容情况：

|      | IS     | IX     | S      | X      |
| ---- | ------ | ------ | ------ | ------ |
| IS   | 兼容   | 兼容   | 兼容   | 不兼容 |
| IX   | 兼容   | 兼容   | 不兼容 | 不兼容 |
| S    | 兼容   | 不兼容 | 兼容   | 不兼容 |
| X    | 不兼容 | 不兼容 | 不兼容 | 不兼容 |

​	**举例**

在对记录r加X锁之前，已经有事务对表1进行了S锁，事务需要对记录r所在的表1上加IX，由于不兼容，所以该事务需要等待表锁操作的完成。

### 2.一致性非锁定读

> 如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会等待行锁的释放，相反地，InnoDB会去读取行的一个快照数据。（InnoDB默认的读取方式，极大提高了并发性能）

- READ COMMITTED : 总是读取锁定行最新一份快照数据
- READ REPEATABLE : 总是读取事务开始时的快照数据



### 3.外键与锁

对于一个外键列，InnoDB会自动对其加一个索引，这样可以避免表锁。



## 四、锁的算法

### 1.行锁的3种算法

- Record Lock：单个行记录上的锁
- Gap Lock：间隙锁，锁定一个范围，但不包括记录本身
- Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，包括记录本身

InnoDB对于行的查询默认使用Next-Key Lock算法，对于唯一索引列的查询（返回结果只有一行数据），Next-Key Lock会降级为Record lock。

```SQL
CREATE TABLE t (a INT PRIMARY KEY);
INSERT INTO t SELECT 1;
INSERT INTO t SELECT 2;
INSERT INTO t SELECT 5;
```

若查询的是辅助索引列，则使用Next-Key Lock，还会对辅助索引下一个键值加上gap lock。



### 2.解决幻读

> 幻读是指同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。

innodb默认使用READ REPEATABLE，InnoDB采用Next-Key Lock算法避免幻读。

而在READ COMMITTED下，仅采用Record Lock。



## 五、锁问题

### 1.脏读

> 当前事务读取到另外事务未提交的数据。

设定为 读已提交(READ COMMITTED) 即可解决。



### 2.不可重复读

> 当前事务读取到另外事务已提交的数据，对于同一数据返回不同结果

设定为 可重复读(READ REPEATABLE) 即可解决。



### 3.幻读

> 当前事务读取到另外事务已提交的数据，不针对数据修改，针对插入和删除，读取的记录数量前后不一致。

设定为 串行化(READ SERIALIZABLE) 即可解决。（Oracle下的解决方式）



**但是在InnoDB的默认事务隔离级别READ REPEATABLE中，通过使用Next-Key Lock算法即可避免幻读的问题。**（同时解决了不可重复读和幻读）



### 4.丢失更新

> 其实，除了**脏读**，**不可重复读**，**幻读**，还有另一种问题，**丢失更新**，即两个事务同时读取同一条记录，A先修改记录，B也修改记录（B是不知道A修改过），B提交数据后B的修改结果覆盖了A的修改结果。

设定为 串行化(READ SERIALIZABLE) 即可解决。



## 六、阻塞、死锁与锁升级

### 1.阻塞

> 一个事物的锁需要等待另一个事务的锁释放它占用的资源。

默认情况下InnoDB存储引擎不会回滚超时引发的错误异常。



### 2.死锁

> 事务因为争夺资源而造成的一种互相等待的现象。

- 采用wait-for graph（等待图）来死锁检测。
- 发现死锁后，InnoDB存储引擎会马上会滚一个事务。（超时不回滚的特例）



### 3.锁升级

> 将当前锁的粒度降低，例如行锁升级为表锁，以降低资源开销。

